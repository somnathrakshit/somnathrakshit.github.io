<!doctype html><html lang=en><head><title>My Git Command Collection :: Terminal</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Like many other people, I tend to be frustrated often trying to find the right command while using Git. This document is an attempt to collect as many useful commands from various places on the internet to make commands easier to find in a single location. I used some excellant resources such as this while creating this.
Before You Begin It is always a good idea to take a backup of your entire working directory including ."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/blog/git_commands/><link rel=stylesheet href=/assets/style.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/img/favicon/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="My Git Command Collection"><meta property="og:description" content="Like many other people, I tend to be frustrated often trying to find the right command while using Git. This document is an attempt to collect as many useful commands from various places on the internet to make commands easier to find in a single location. I used some excellant resources such as this while creating this.
Before You Begin It is always a good idea to take a backup of your entire working directory including ."><meta property="og:url" content="/blog/git_commands/"><meta property="og:site_name" content="Terminal"><meta property="og:image" content="/img/favicon/orange.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-03-15 00:00:00 +0000 UTC"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Somnath Rakshit</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/blog>Blog</a></li><li><a href=/contact>Contact</a></li><li><a href=/projects>Projects</a></li><li><a href=/files/somnathrakshit_resume.pdf>Resume</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/blog>Blog</a></li><li><a href=/contact>Contact</a></li><li><a href=/projects>Projects</a></li><li><a href=/files/somnathrakshit_resume.pdf>Resume</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/blog/git_commands/>My Git Command Collection</a></h1><div class=post-meta><span class=post-date>2021-03-15</span></div><div class=post-content><div><p>Like many other people, I tend to be frustrated often trying to find the right command while using Git. This document is an attempt to collect as many useful commands from various places on the internet to make commands easier to find in a single location. I used some excellant resources such as <a href=https://sethrobertson.github.io/GitFixUm/fixup.html>this</a> while creating this.</p><h2 id=before-you-begin>Before You Begin<a href=#before-you-begin class=hanchor arialabel=Anchor>&#8983;</a></h2><p>It is always a good idea to take a backup of your entire working directory including .git before you attempt anything mentioned here.</p><h2 id=saving-uncommitted-changes>Saving Uncommitted Changes<a href=#saving-uncommitted-changes class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Sometimes, you might work on something before realising that you won&rsquo;t need it at that point of time. If you don&rsquo;t want to delete that work, and instead, save it for some other day, here are some of the things that you can do.</p><table><thead><tr><th>Description</th><th>Command</th></tr></thead><tbody><tr><td>Commit them on the local branch</td><td><code>git commit -am "My descriptive message"</code></td></tr><tr><td>Commit them on another branch, no checkout conflicts.</td><td><code>git checkout otherbranch && git commit -am "My descriptive message"</code></td></tr><tr><td>Commit them on another branch, conflicts.</td><td><code>git stash; git checkout otherbranch; git stash apply; : "resolve conflicts"; git commit -am "My descriptive message"; git stash drop</code></td></tr><tr><td>Commit them on a new branch.</td><td><code>git checkout -b newbranch; git commit -am "My descriptive message"</code></td></tr><tr><td>Stash them for a rainy day.</td><td><code>git stash save "my descriptive name"</code></td></tr></tbody></table><h2 id=how-to-undo-all-uncommitted-changes>How to undo all uncommitted changes<a href=#how-to-undo-all-uncommitted-changes class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So you have not yet committed and you want to undo everything. Well, best practice is for you to stash the changes in case you were mistaken and later decide that you really wanted them after all. <code>git stash save "description of changes"</code>. You can revisit those stashes later by <code>git stash list</code> and decide whether to <code>git stash drop</code> them after some time has past. Please note that untracked and ignored files are not stashed by default. See <code>"--include-untracked"</code> and <code>"--all"</code> for stash options to handle those two cases.</p><p>However, perhaps you are confident (or arrogant) enough to know for sure that you will never ever want the uncommitted changes. If so, you can run <code>git reset --hard</code>, however please be quite aware that this is almost certainly a completely unrecoverable operation. Any changes which are removed here cannot be restored later. This will not delete untracked or ignored files. Those can be deleted with <code>git clean -nd; git clean -ndX</code> respectively, or <code>git clean -ndx</code> for both at once. Well, actually those command do not delete the files. They show what files will be deleted. Replace the <code>"n"</code> in <code>"-nd…"</code> with <code>"f"</code> to actually delete the files. Best practice is to ensure you are not deleting what you should not by looking at the moribund filenames first.</p><h2 id=how-to-undo-some-uncommitted-changes>How to undo some uncommitted changes<a href=#how-to-undo-some-uncommitted-changes class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So you have not yet committed and you want to undo some things. Well, <code>git status</code> will tell you exactly what you need to do. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git status
</span></span><span style=display:flex><span><span style=color:#75715e># On branch master</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes to be committed:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       new file:   .gitignore</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Changes not staged for commit:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       modified:   A</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Untracked files:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#       C</span>
</span></span></code></pre></div><p>However, the <code>git checkout</code> in file mode is a command that cannot be recovered from—the changes which are discarded most probably cannot be recovered. Perhaps you should run <code>git stash save -p "description"</code> instead, and select the changes you no longer want to be stashed instead of zapping them.</p><h2 id=do-you-have-uncommitted-stuff-in-your-working-directory>Do you have uncommitted stuff in your working directory?<a href=#do-you-have-uncommitted-stuff-in-your-working-directory class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So you have committed. However, before we go about fixing or removing whatever is wrong, you should first ensure that any uncommitted changes are safe, by either committing them (<code>git commit</code>) or by stashing them (<code>git stash save "message"</code>) or getting rid of them.</p><p><code>git status</code> will help you understand whether your working directory is clean or not. It should report nothing for perfect safety (&ldquo;Untracked files&rdquo; only are sometimes safe.)</p><h3 id=discarding-all-local-commits-on-this-branch>Discarding all local commits on this branch<a href=#discarding-all-local-commits-on-this-branch class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In order to discard all local commits on this branch, to make the local branch identical to the &ldquo;upstream&rdquo; of this branch, simply run <code>git reset --hard @{u}</code>.</p><h3 id=replacing-all-branch-historycontents>Replacing all branch history/contents<a href=#replacing-all-branch-historycontents class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If instead of discarding all local commits, you can make your branch identical to some other branch, tag, ref, or SHA that exists on your system.</p><p>The first thing you need to do is identify the SHA or ref of the good state of your branch. You can do this by looking at the output of <code>git log --all</code> or look graphically at <code>gitk --all --date-order</code>.</p><p>Once you have found the correct state of your branch, you can get to that state by running <code>git reset --hard REF</code>.
Obviously replace <code>REF</code> with the reference or SHA you want to get back to.</p><h2 id=removing-the-last-commit>Removing the last commit<a href=#removing-the-last-commit class=hanchor arialabel=Anchor>&#8983;</a></h2><p>To remove the last commit from git, you can simply run <code>git reset --hard HEAD^</code> If you are removing multiple commits from the top, you can run <code>git reset --hard HEAD~2</code> to remove the last two commits. You can increase the number to remove even more commits.</p><p>If you want to &ldquo;uncommit&rdquo; the commits, but keep the changes around for reworking, remove the <code>--hard</code>: <code>git reset HEAD^</code> which will evict the commits from the branch and from the index, but leave the working tree around.</p><p>If you want to save the commits on a new branch name, then run <code>git branch newbranchname</code> before doing the git reset.</p><h2 id=reworking-the-last-commit>Reworking the last commit<a href=#reworking-the-last-commit class=hanchor arialabel=Anchor>&#8983;</a></h2><p>WARNING: These techniques should only be used for non-merge commits. If you have a merge commit, you are better off deleting the merge and recreating it.</p><p>If you want to perform significant work on the last commit, you can simply <code>git reset HEAD^</code>. This will undo the commit (peel it off) and restore the index to the state it was in before that commit, leaving the working directory with the changes uncommitted, and you can fix whatever you need to fix and try again.</p><p>You can do this with multiple (non-merge) commits in a row (using <code>HEAD^^</code> or similar techniques), but then of course you lose the separation between the commits and are left with an undifferentiated working directory. If you are trying to squash all of the commits together, or rework which bits are in which commits, this may be what you want.</p><h2 id=moving-a-commit-from-one-branch-to-another>Moving a commit from one branch to another<a href=#moving-a-commit-from-one-branch-to-another class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So, you have a commit which is in the wrong place and you want to move it from one branch to another. In order to do this, you will need to know the SHA of the first and last commit (in a continuous series of commits) you want to move (those values are the same if you are moving only one commit), the name of the branch you are moving the commit from, and the name of the branch you are moving the commit to. In the example below, I will name these four values <code>$first</code>, <code>$last</code>, <code>$source</code>, and <code>$destination</code> (respectively). Additionally, you will need to use a nonce branch as a placeholder. I will call the nonce branch <code>nonce</code> in the following example. However, you may use any branch name that is not currently in use. You can delete it immediately after you are done.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch nonce $last
</span></span><span style=display:flex><span>git rebase -p --onto $destination $first^ nonce
</span></span></code></pre></div><p>Remember that when you substitute <code>$first</code> in the command above, leave the <code>^</code> alone, it is literal.</p><p>Use <code>gitk --all --date-order</code> to check to make sure the move looks correct (pretending that nonce is the destination branch). Please check very carefully if you were trying to move a merge, it may have been recreated improperly. If you don&rsquo;t like the result, you may delete the nonce branch (<code>git branch -D nonce</code>) and try again.</p><p>However, if everything looks good, we can move the actual destination branch pointer to where nonce is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout $destination
</span></span><span style=display:flex><span>git reset --hard nonce
</span></span><span style=display:flex><span>git branch -d nonce
</span></span></code></pre></div><p>If you double-checked with <code>gitk --all --date-order</code>, you would see that the destination branch looks correct. However, the commits are still on the source branch as well. We can get rid of those now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git rebase -p --onto $first^ $last $source
</span></span></code></pre></div><p>Using <code>gitk --all --date-order</code> one last time, you should now see that the commits on the source branch have gone away. You have successfully moved the commits. Please check very carefully if merges occurred after the commits which were deleted. They may have been recreated incorrectly. If so you can either undo the delete or try to delete the bad merge and try to recreate it manually, or create a fake (&ndash;ours) merge from the same SHA so that git is aware that the merge occurred.</p><h2 id=undoing-the-last-few-git-operations-affecting-headmy-branchs-tip>Undoing the last few git operations affecting HEAD/my branch&rsquo;s tip<a href=#undoing-the-last-few-git-operations-affecting-headmy-branchs-tip class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Practically every git operation which affects the repository is recorded in the git reflog. You may then use the reflog to look at the state of the branches at previous times or even go back to the state of the local branch at the time.</p><p>While this happens for every git command affecting HEAD, it is usually most interesting when attempting to recover from a bad rebase or reset or an <code>--amend</code>&lsquo;ed commit. There are better ways (listed by the rest of this document) from recovering from the more mundane reflog updates.</p><p>The first thing you need to do is identify the SHA of the good state of your branch. You can do this by looking at the output of <code>git log -g</code> or, my preference, you can look graphically at <code>gitk --all --date-order $(git log -g --pretty=%H)</code>.</p><p>Once you have found the correct state of your branch, you can get back to that state by running</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git reset --hard SHA
</span></span></code></pre></div><p>You could also link that old state to a new branch name using</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b newbranch SHA
</span></span></code></pre></div><p>Obviously replace <code>SHA</code> in both commands with the reference you want to get back to.</p><p>Note that any other commits you have performed since you did that &ldquo;bad&rdquo; operation will then be lost. You could <code>git cherry-pick</code> or <code>git rebase -p --onto</code> those other commits over.</p><script async src=https://comments.app/js/widget.js?3 data-comments-app-website=u3US6zJB data-limit=5 data-color=343638></script></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div></body></html>